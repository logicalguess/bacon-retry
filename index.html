<html>
<head>
    <script type="text/javascript" src="lib/jquery.js"></script>
    <script type="text/javascript" src="lib/jquery.mockjax.js"></script>
    <script type="text/javascript" src="lib/Bacon.js"></script>
    <script type="text/javascript" src="lib/bacon.model.js"></script>
    <script type="text/javascript" src="lib/bacon.jquery.js"></script>
    <script type="text/javascript" src="mocks.js"></script>
</head>
<body>

<div id="retry-container">
    <h1>Bacon Retry</h1>

    <div id="service-call">
        <div><b>URLs to try in order: </b><span id="service-urls"></span></div><br><br>
        <button>Make the call</button>
        <input type="checkbox" id="ignoreSlowSuccess" value="false">Ignore Late Successful Responses<br><br>
        <div>Result: <span id="service-result"></span></div>
    </div>
</div>

<script type="text/javascript">

    var delayMs = 2000;
    var urls = ['/api/success/slow', '/api/error/500', '/api/error/500/slow', '/api/success', '/api/error/500'];

    var submitInteraction = {
        element: $('#service-call button'),
        event: 'click'
    };
    var resultInteraction = {
        element: $("#service-result")
    };
    $("#service-urls").html('<br><br>' + urls.join('<br>'));

    var showResult = function(txt) {
        resultInteraction.element.text(txt);
    }

    var submits = submitInteraction.element.asEventStream(submitInteraction.event).doAction('.preventDefault');

    submits.onValue(function(){
        var serviceCall = retrySM(urls, delayMs, $('#ignoreSlowSuccess').is(':checked'));

        serviceCall.pending.onValue(showResult, "Pending...");
        serviceCall.result.onValue(showResult);
        serviceCall.result.onError(showResult);
    });

    function retry(urls, delayMs, ignoreSlowSuccess) {
        var state = {
            promises: [],
            getCount: function () {
                return this.promises.length;
            },
            isAnyResolved: function () {
                for (var i = 0; i < this.promises.length; i++) {
                    if (this.promises[i].state() == 'resolved') {
                        return true;
                    }
                }
                return false;
            },
            isResolved: function() {
                if (this.promises.length == 0) return false;
                return ignoreSlowSuccess ? this.getLast().state() == 'resolved' : this.isAnyResolved();
            },
            getFirstResolved: function () {
                for (var i = 0; i < this.promises.length; ++i) {
                    if (this.promises[i].state() == 'resolved')
                        return this.promises[i];
                }
            },
            getLast: function () {
                return this.promises[this.promises.length - 1];
            },
            add: function (promise) {
                this.promises.push(promise);
            },
            getHistory: function () {
                if (this.promises.length == 0) {
                    return new Bacon.never();
                }

                var stream = Bacon.fromPromise(this.promises[0]);
                if (this.promises.length > 1) {
                    for (var i = 1; i < this.promises.length; ++i) {
                        stream = stream.concat(this.promises[i]);
                    }
                }
                return stream;
            },
            getResult: function() {
                var fr = this.getFirstResolved();
                return Bacon.fromPromise(fr ? fr : this.getLast());
            }
        };

        var pipe = Bacon.once(urls.shift()).concat(Bacon.sequentially(delayMs, urls))
                .withStateMachine(state, function(state, event) {
                    if (state.promises.length > 0) console.log(state.promises[0].state(), state.isResolved())
                    if (state.isResolved() || event.isEnd()) {
                        return [state, [new Bacon.Next(state), new Bacon.End()]]
                    }
                    else {
                        state.add($.ajax({url: event.value()}));
                        return [state, [new Bacon.Next(state)]];
                    }
                })//.log();

        return {
            result: pipe.filter(function(state){
                return state.isResolved() || (state.getCount() == urls.length);
            }).flatMap(function(state){return state.getResult()}),
            pending: pipe.filter(function(state){
                return !(state.isResolved() || (state.getCount() == urls.length));
            }).map(Boolean)
        };
    }
</script>

</body>
</html>
